"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveProjectPath = exports.toCamelCase = exports.capitalize = exports.toSnakeCase = exports.findArgumentValue = exports.combine = exports.traverseArgvMatching = exports.findLastIndex = void 0;
const debug_1 = __importDefault(require("../debug"));
const path_helpers_1 = require("../path-helpers");
function findLastIndex(collection, predicate, beforeIndex = collection.length) {
    for (let i = beforeIndex - 1; i >= 0; --i) {
        if (predicate(collection[i])) {
            return i;
        }
    }
    return -1;
}
exports.findLastIndex = findLastIndex;
function* traverseArgvMatching(argv, name, allowEqual) {
    let beforeIndex = argv.length, matchingIndex;
    while ((matchingIndex = findLastIndex(argv, (arg) => arg.startsWith(name), beforeIndex)) !== -1) {
        if (argv[matchingIndex] === name) {
            if (argv.length - 1 === matchingIndex) {
                (0, debug_1.default)(`'${name}' argument missing`);
            }
            else {
                yield argv[matchingIndex + 1];
            }
        }
        else if (allowEqual && argv[matchingIndex][name.length] === "=") {
            yield argv[matchingIndex].slice(name.length + 1);
        }
        beforeIndex = matchingIndex;
    }
}
exports.traverseArgvMatching = traverseArgvMatching;
function* combine(...generators) {
    for (const generator of generators) {
        yield* generator;
    }
}
exports.combine = combine;
function findArgumentValue(argv, name, allowEqual) {
    for (const value of traverseArgvMatching(argv, name, allowEqual)) {
        return value;
    }
}
exports.findArgumentValue = findArgumentValue;
function toSnakeCase(value) {
    return value.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
exports.toSnakeCase = toSnakeCase;
function capitalize(word) {
    return word.toLowerCase().replace(/\b\w/g, (l) => l.toUpperCase());
}
exports.capitalize = capitalize;
function toCamelCase(value) {
    return value
        .split("_")
        .map((word, index) => index === 0 ? word.toLocaleLowerCase() : capitalize(word))
        .join("");
}
exports.toCamelCase = toCamelCase;
function resolveProjectPath(options) {
    const { argv, cwd } = options;
    const customProjectPath = findArgumentValue(argv, "--project", true) ||
        findArgumentValue(argv, "-P", false);
    if (customProjectPath) {
        return (0, path_helpers_1.ensureIsAbsolute)(cwd, customProjectPath);
    }
    else {
        return cwd;
    }
}
exports.resolveProjectPath = resolveProjectPath;
