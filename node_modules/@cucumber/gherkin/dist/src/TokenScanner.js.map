{"version":3,"file":"TokenScanner.js","sourceRoot":"","sources":["../../src/TokenScanner.ts"],"names":[],"mappings":";;AAGA;;;;;;GAMG;AACH,MAAqB,YAAY;IAI/B,YACE,MAAc,EACG,SAA2E;QAA3E,cAAS,GAAT,SAAS,CAAkE;QALtF,eAAU,GAAG,CAAC,CAAA;QAOpB,IAAI,CAAC,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;QAClC,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,IAAI,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,EAAE;YAC5E,IAAI,CAAC,KAAK,CAAC,GAAG,EAAE,CAAA;SACjB;IACH,CAAC;IAEM,IAAI;QACT,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,CAAA;QAC1C,MAAM,QAAQ,GAAG;YACf,IAAI,EAAE,IAAI,CAAC,UAAU;SACtB,CAAA;QACD,OAAO,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAA;IACvC,CAAC;CACF;AArBD,+BAqBC","sourcesContent":["import IToken from './IToken'\nimport * as messages from '@cucumber/messages'\n\n/**\n * The scanner reads a gherkin doc (typically read from a .feature file) and creates a token for each line.\n * The tokens are passed to the parser, which outputs an AST (Abstract Syntax Tree).\n *\n * If the scanner sees a `#` language header, it will reconfigure itself dynamically to look for\n * Gherkin keywords for the associated language. The keywords are defined in gherkin-languages.json.\n */\nexport default class TokenScanner<TokenType> {\n  private lineNumber = 0\n  private lines: string[]\n\n  constructor(\n    source: string,\n    private readonly makeToken: (line: string, location: messages.Location) => IToken<TokenType>\n  ) {\n    this.lines = source.split(/\\r?\\n/)\n    if (this.lines.length > 0 && this.lines[this.lines.length - 1].trim() === '') {\n      this.lines.pop()\n    }\n  }\n\n  public read(): IToken<TokenType> {\n    const line = this.lines[this.lineNumber++]\n    const location = {\n      line: this.lineNumber,\n    }\n    return this.makeToken(line, location)\n  }\n}\n"]}